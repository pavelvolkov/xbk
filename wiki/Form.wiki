=Генератор веб-форм=

Модуль генерации веб-форм предоставляет объектный интерфейс для построения и обработки формы любой конструкции. Данный модуль функционирует даже в неустановленном состоянии. В наличии имеется полный набор типов полей с возможностью их группировки и формирования иерархии:
 * текстовое поле
 * многострочное текстовое поле
 * поле ввода пароля
 * поле загрузки файла
 * скрытое поле
 * выпадающий список
 * чекбокс
 * группа радиокнопок
 * группа чекбоксов
 * html-поле
 * кнопка отправки формы
 * группа кнопок отправки формы

==Создание объекта формы==

Чтобы построить свёрстанную web-форму, для начала необходимо инстанцировать объект класса "xbkForm", сообщив ему ряд параметров через конструктор:
{{{
$values = Array();
$options = Array(
    'title' => 'My form',
    'action' => $this->uri()->build(),
    'method' => 'post', 
    'width' => '400px',
    'validate' => Array($this, 'validateForm'),
    'handle' => Array($this, 'handleForm'),
);
$this->loadClass('xbkForm', 'form', true);
$Form = $this->factory('xbkForm', 'my_form', $options, $values);
}}}
Первый параметр "my_form" является идентификатором формы, используется в CSS и для идентификации через точку расширения "form" данного модуля. Второй параметр сообщает ряд опций в форме массива:
 * *extendable* - флаг, указывающий, что форма имеет возможность дополнения через точку расширения "form" (по-умолчанию - true);
 * *template* - шаблон формы, перекрывающий шаблон по-умолчанию - объект класса "xbkPhptemplate";
 * *title* - заголовок формы;
 * *action* - адрес отправки формы;
 * *method* - метод отправки (get, post, put), по-умолчанию равен "post";
 * *width* - ширина в пикселах или в процентах;
 * *enctype* - тип кодировки, по-умолчанию - "text/plain" (но если мы используем поле загрузки файла, параметр "enctype" заменяется автоматически на "multipart/form-data");
 * *validate* - callback-метод валидации;
 * *handle* - callback-метод обработки;

Массив $values содержит значения полей формы по-умолчанию. Если мы редактируем существующие данные в базе, их нужно указать в этом маасиве. Формат массива: ключ - имя элемента формы, значение - значение, соответственно.

==Добавление элементов==

Под элементом формы понимается поле ввода типа "input", "select", "submit", а также группа полей и пользовательское поле (внедрение html). Каждому элементу формы должны быть назначены имя, вес и ряд специфичных данному элементу характеристик. Имя элемента используется в качестве имени поля web-формы и для идентификации элемента внутри объекта класса "xbkForm" и "xbkFormGroup". Вес определяет положение в порядке отображения полей.
Есть два способа добавления поля в форму. Стандартный способ:
{{{
$definition = Array(
    'name' => 'login',
    'weight' => 1,
    'title' => 'Login',
    'description' => 'You may use only letters, digits and dash.',    
    'required' => true,
    'maxlength' => 40,    	
    'size' => 20,    
);
$this->loadClass('xbkFormText', 'form', true);
$LoginElement = $this->factory('xbkFormText', $definition);
$Form->addElement($LoginElement);
}}}
Сперва создаём объект элемента формы - в нашем случае это простое текстовое поле - потом его подставляем в объект формы с помощью метода "addElement()". Свойства элемента сообщаем массивом в коструктор при создании элемента. Первые два элемента массива с описанием поля, соответственно, его имя и вес.
Упрощённый способ:
{{{
$definition = Array(
    'title' => 'Login',
    'description' => 'You may use only letters, digits and dash.',    
    'required' => true,
    'maxlength' => 40,    	
    'size' => 20,    
);
$Form->addElement('text', 'login', $definition, 1);
}}}
Здесь нам не нужно создавать объект элемента формы - достаточно сообщить методу "addElement()" в указанном порядке тип поля, имя, специфичные данному полю свойства, вес. В этом случае нет необходимости прописывать имя и вес в массив $definition.

==Построение формы==

Когда мы закончим подстановку полей, мы уже можем сгенерировать html методом "build()":
{{{
$rendered_form = $Form->build();
}}}
В момент запуска метода "build()" поизводится валидация и обработка формы (если получены данные предыдущего заполнения), кроме того объект формы передаётся через точку расширения "form" для дополнения другими полями. Чтобы запретить возможность расширять форму нужно установить свойство "extendable" равным false. Форма строится по шаблону "form.tpl.php", который находится в папке скина модуля формы. Перекрыть шаблон можно, сообщив свой объект шаблона методом "setTemplate()", либо передав его свойством "template" в массиве опций формы.

==Валидация и обработка==

Валидация - это проверка введённых данных на корректность заполнения. Callback-медод валидации сообщается объекту формы в опции "validate". Пример метода валидации:
{{{
    /**
     * Валидация формы
     *
     * @access      public
     * @param       array
     * @param       object xbkErrorStack
     * @return      boolean
     */
    public function validate (&$values, xbkErrorStack $ErrorStack)
    {
    	$pattern = '`^[a-zA-Z0-9'.preg_quote('-_', '`').']{5,30}$`';
    	
    	if (empty($values['apply'])) {
    		// Дальнейшая валидация и обработка формы не производится
    		return false;
    	}
    	
    	// Логин
    	if (empty($values['login'])) {
    		$ErrorStack->addError($this->_LANG['example3_error_login_empty'], null, 'login');
    	} else {   		
    		if (strlen($values['login']) < 5) {
    			$str = str_replace('{min}', 5, $this->_LANG['example3_error_login_short']);
    			$ErrorStack->addError($str, null, 'login');
    		}
    		if (strlen($values['login']) > 30) {
    			$str = str_replace('{max}', 30, $this->_LANG['example3_error_login_long']);
    			$ErrorStack->addError($str, null, 'login');
    		}
    		// Соответствие по символам    		
    		if (preg_match($pattern, $values['login']) === 0 ? true : false) {
    			$ErrorStack->addError($this->_LANG['example3_error_login_incorrect'], null, 'login');
    		}
    	}
    	
    	// Пароль
    	if (empty($values['pass'])) {
    		$ErrorStack->addError($this->_LANG['example3_error_pass_empty'], null, 'pass');
    	} else {   		
    		if (strlen($values['pass']) < 5) {
    			$str = str_replace('{min}', 5, $this->_LANG['example3_error_pass_short']);
    			$ErrorStack->addError($str, null, 'pass');
    		}
    		if (strlen($values['pass']) > 30) {
    			$str = str_replace('{max}', 30, $this->_LANG['example3_error_pass_long']);
    			$ErrorStack->addError($str, null, 'pass');
    		}
    		// Соответствие по символам    		
    		if (preg_match($pattern, $values['pass']) === 0 ? true : false) {
    			$ErrorStack->addError($this->_LANG['example3_error_pass_incorrect'], null, 'pass');
    		}
    		
    		// Повторный ввод
    		if (empty($values['pass2'])) {
    			$ErrorStack->addError($this->_LANG['example3_error_pass_empty'], null, 'pass2');
    		} else {
    			if (strlen($values['pass2']) < 5) {
    				$str = str_replace('{min}', 5, $this->_LANG['example3_error_pass_short']);
    				$ErrorStack->addError($str, null, 'pass2');
    			}
    			if (strlen($values['pass2']) > 30) {
    				$str = str_replace('{max}', 30, $this->_LANG['example3_error_pass_long']);
    				$ErrorStack->addError($str, null, 'pass2');
    			}
    			// Соответствие по символам
    			if (preg_match($pattern, $values['pass2']) === 0 ? true : false) {
    				$ErrorStack->addError($this->_LANG['example3_error_pass_incorrect'], null, 'pass2');
    			}    			
    		}
    		
    		$pass_errors = $ErrorStack->getMessagesByFormField('pass');
    		$pass2_errors = $ErrorStack->getMessagesByFormField('pass2');
    		if (count($pass_errors) == 0 && count($pass2_errors)) {
    			if ($values['pass'] != $values['pass2']) {
    				$ErrorStack->addError($this->_LANG['example3_error_pass_not_equal'], null, 'pass');
    			}
    		}
    	}
    	
    	// E-mail
    	if (empty($values['email'])) {
    		$ErrorStack->addError($this->_LANG['example3_error_email_empty'], null, 'email');
    	} else {
    		$Validate = new Zend_Validate;
    		$Validate->addValidator(new Zend_Validate_EmailAddress);
    		$result = $Validate->isValid($values['email']);
    		if (!$result) {
    			$ErrorStack->addError($this->_LANG['example3_error_email_invalid'], null, 'email');
    		}
    	}
    	
    	// Ник
    	if (empty($values['nik'])) {
    		$ErrorStack->addError($this->_LANG['example3_error_nik_empty'], null, 'nik');
    	}
    	
    	// ФИО
    	if (empty($values['fio_f'])) {
    		$ErrorStack->addError($this->_LANG['example3_error_fio_f_empty'], null, 'fio_f');
    	}
    	if (empty($values['fio_i'])) {
    		$ErrorStack->addError($this->_LANG['example3_error_fio_i_empty'], null, 'fio_i');
    	}
    	if (empty($values['fio_o'])) {
    		$ErrorStack->addError($this->_LANG['example3_error_fio_o_empty'], null, 'fio_o');
    	}
    	
    	if (empty($values['additional'])) {
    		$ErrorStack->addError($this->_LANG['example3_error_additional_empty'], null, 'additional');
    	}
    	$opt = Array('work', 'study', 'work_study', 'without_work', 'pensioner');
    	if (empty($values['social_status']) ? true : !in_array($values['social_status'], $opt)) {
    		$ErrorStack->addError($this->_LANG['example3_error_social_status_empty'], null, 'social_status');
    	}
    	$opt = Array(11, 12, 13, 21, 22, 23, 31, 32, 33);
    	if (empty($values['interests']) ? true : (!is_array($values['interests']) ? true : (array_diff($values['interests'], $opt) == $opt))) {
    		$ErrorStack->addError($this->_LANG['example3_error_interests_empty'], null, 'interests');
    	}
    	
    	// Обработка загрузки файла
    	if (!empty($this->_FILES['profile_avatar_file']['name'])) {
    		$ErrorStack->addError($this->_LANG['example3_error_avatar_invalid'], null, 'profile_avatar_file');
    		if (!empty($values['profile_avatar_crop'])) {
    			$ErrorStack->addError($this->_LANG['example3_error_avatar_crop_invalid'], null, 'profile_avatar_crop');
    		}
    	}
    	
    }
}}}