Изменение структуры данных - очень ответственная процедура в проектировании приложений. Принимая во внимание то обстоятельство, что в системе xBk доступ к данным осуществляется через слой абстракции посредством моделей в виде классов, не рекомендуется вносить никакие изменения непосредственно в самой базе, минуя этот слой. Рассогласование фактической структуры данных и её модельного представления чревато некорректностью работы модуля и даже фатальными ошибками. Кроме того, в задаче обеспечения повторяемости модулей в различных проектах, вопрос версионирования и фиксации изменений в целях обновления структуры без потери данных приобретает насущную важность - в этом случае не избежать необходимости ведения истории миграции данных.
История миграций служит не только записной книжкой разработчика, но и самим инструментом для осуществления переезда с одной структуры на другую. Миграции представляются в виде классов, производных от базового "Doctrine_Migration", хранятся в подпапке "migrations" папки рабочего модуля. Задание механизма изменения структуры осуществляется за счёт методов "up()" и "down()", которые означают, соответственно, процесс внесения изменений, их отмену и представляют собой один шаг миграции данных в прямую и обратную сторону. Имя класса может быть произвольным (но на всякий случай желательно использовать суффикс "_Migration" во избежание конфликтых ситуаций), а имя файла, содержащего класс, должно начинаться с префикса, который указывает на порядковый номер текущего состояния. Пример: "XXX_representative_name.class.php".
{{{
<?php

// 001_add_table.class.php
class AddTable_Migration extends Doctrine_Migration
{
    public function up()
    {
        global $CONFIG;
        $this->createTable($CONFIG['db']['table_prefix'].'migration_test', array('field1' => array('type' => 'string')));
    }

    public function down()
    {
        global $CONFIG;
        $this->dropTable($CONFIG['db']['table_prefix'].'migration_test');
    }
}

// 002_add_column.class.php
class AddColumn_Migration extends Doctrine_Migration
{
    public function up()
    {
        global $CONFIG;
        $this->addColumn($CONFIG['db']['table_prefix'].'migration_test', 'field1', 'string');
    }

    public function down()
    {
        global $CONFIG;
        $this->renameColumn($CONFIG['db']['table_prefix'].'migration_test', 'field1', 'field2');
    }
}

// 003_change_column.class.php
class ChangeColumn_Migration extends Doctrine_Migration
{
    public function up()
    {
        global $CONFIG;
        $this->changeColumn($CONFIG['db']['table_prefix'].'migration_test', 'field1', 'integer');
    }

    public function down()
    {
        global $CONFIG;
        $this->changeColumn($CONFIG['db']['table_prefix'].'migration_test', 'field1', 'string');
    }
}

?>
}}}
Ниже представлен список доступных методов, которые можно использвать в миграционном классе:
{{{
<?php

public function createTable($tableName, array $fields = array(), array $options = array())
public function dropTable($tableName)
public function renameTable($oldTableName, $newTableName)
public function createConstraint($tableName, $constraintName, array $definition)
public function dropConstraint($tableName, $constraintName, $primary = false)
public function createForeignKey($tableName, array $definition)
public function dropForeignKey($tableName, $fkName)
public function addColumn($tableName, $columnName, $type, array $options = array())
public function renameColumn($tableName, $oldColumnName, $newColumnName)
public function changeColumn($tableName, $columnName, $type, array $options = array())
public function removeColumn($tableName, $columnName)
public function addIndex($tableName, $indexName, array $options = array())
public function removeIndex($tableName, $indexName)

?>
}}}
Управление миграциями осуществляется в панели суперадмина индивидуально для каждого модуля. При разработке нового модуля писать миграционный класс не нужно - первичная установка выполняется с помощью действия "установить" в списке действий, что создаёт необходимые таблицы БД. Пока не было произведено смены структуры посредством механизма миграций, текущая миграция будет всегда обозначаться как "не определена / не задана". Такая же надпись появится, если переустановить ядро системы или удалить регистрацию модуля, поэтому, чтобы не пришлось потом работать вслепую, этого делать не рекомедуется.